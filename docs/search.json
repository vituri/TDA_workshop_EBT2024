[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TDA Workshop - EBT 2024",
    "section": "",
    "text": "1 Intro\nTo be done!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Intro</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html",
    "href": "3d-shapes.html",
    "title": "2  3d shape classification using persistent homology",
    "section": "",
    "text": "2.1 The dataset\nThe dataset we are using is !!!citar. It consists of !!!. The files can be downloaded at !!!. After downloading it, unzip the file and put then inside a directory called “meshes”. !!! jogou fora gallopes\nThe files are written in the “.obj” format. They are meshes: sets of points and triangles that forma 3d image like the ones we can see in videogames.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#loading-some-libraries",
    "href": "3d-shapes.html#loading-some-libraries",
    "title": "2  3d shape classification using persistent homology",
    "section": "3.1 Loading some libraries",
    "text": "3.1 Loading some libraries\n\nusing Meshes, GeoIO\nimport GLMakie as gl\nimport DelimitedFiles\nusing ProgressMeter\n\nusing Graphs, SimpleWeightedGraphs\nusing MetricSpaces, Ripserer, PersistenceDiagrams\nusing Chain\n\n\n# functions\nfunction reduz_obj(arquivo, n_points=1000)\n    geotable = GeoIO.load(arquivo)\n\n    X_total = geotable.vertices .|&gt; coordinates .|&gt; Vector |&gt; EuclideanSpace\n\n    ids = farthest_points_sample(X_total, n_points)\n    X = X_total[ids]\n\n    arquivo_novo = replace(arquivo, \".obj\" =&gt; \".csv\")\n    DelimitedFiles.writedlm(arquivo_novo, stack(X)' |&gt; Matrix, \",\")\n\n    X\nend\n\nfunction meshes_to_csv(dir_path)\n    for (root, dirs, files) ∈ collect(walkdir(dir_path))\n        for file ∈ files\n            if occursin(\".obj\", file)\n                arquivo = joinpath(root, file)\n                println(arquivo)\n                reduz_obj(arquivo)\n            end\n        end\n    end\nend\n\nread_mesh(arquivo) = GeoIO.load(arquivo).geometry\n\nfunction mesh_to_graph(ms, X)\n    g = SimpleWeightedGraph()\n    n = length(X)\n    add_vertices!(g, n)\n\n    triangles = ms.topology.connec\n\n    @showprogress desc = \"Adding vertices to graph...\" for t ∈ triangles\n        v1, v2, v3 = t.indices\n        add_edge!(g, v1, v2, dist_euclidean(X[v1], X[v2]))\n\n        add_edge!(g, v1, v3, dist_euclidean(X[v1], X[v3]))\n\n        add_edge!(g, v2, v3, dist_euclidean(X[v2], X[v3]))\n    end\n\n    g\nend\n\nmesh_to_metric_space(ms) = ms.vertices .|&gt; coordinates .|&gt; Vector |&gt; EuclideanSpace\n\nfunction geodesic_distance_from_graph(g, ids)\n    n = length(ids)\n    D = zeros(n, n)\n\n    @showprogress desc = \"Calculating geodesic distance...\" Threads.@threads for (i, id) ∈ collect(enumerate(ids))\n        dts = dijkstra_shortest_paths(g, id)\n        D[i, :] = dts.dists[ids]\n    end\n\n    return D\nend\n\nplot_mesh(ms) = viz(ms);\n\n\nms = read_mesh(\"meshes/flamingo-poses/flam-01.obj\")\n# ms = GeoIO.load(\"meshes/flamingo-poses/flam-01.obj\")\n\nplot_mesh(ms)\n\n┌ Warning: Found `resolution` in the theme when creating a `Scene`. The `resolution` keyword for `Scene`s and `Figure`s has been deprecated. Use `Figure(; size = ...` or `Scene(; size = ...)` instead, which better reflects that this is a unitless size and not a pixel resolution. The key could also come from `set_theme!` calls or related theming functions.\n└ @ Makie ~/.julia/packages/Makie/VRavR/src/scenes.jl:220\n\n\n\n\n\n\n# # componentes\n# function barcode_from_mesh(ms, n_points=1000)\n#     X_total = mesh_to_metric_space(ms)\n\n#     g = mesh_to_graph(ms, X_total)\n\n#     componentes_g = connected_components(g)\n#     ids_maior_componente = componentes_g[findmax(length, componentes_g)[2]]\n\n#     X_total = X_total[ids_maior_componente]\n\n#     g = g[ids_maior_componente]\n\n\n#     fts_sample = farthest_points_sample(X_total, n_points)\n#     X = X_total[fts_sample]\n#     D = geodesic_distance_from_graph(g, fts_sample)\n\n#     # force simmetry on X\n#     for i ∈ 1:n_points\n#         for j ∈ i:n_points\n#             D[i, j] = D[j, i]\n#         end\n#     end\n\n#     max_dist = maximum(D)\n#     D = D ./ max_dist\n\n#     pd = ripserer(D, dim_max = 2, verbose=true, sparse = true, threshold = 0.9)\n\n#     pd, D, X, g\n\n# end\n\n# pd, D, X, g = barcode_from_mesh(ms, 300)\n\n# exc = mapslices(sum, D, dims=2) |&gt; vec\n\n# gl.scatter(X, color=exc)\n\n# import Plots\n# Plots.plot(pd)\n# barcode(pd)\n\n\n# calcula pds\n# function list_files(path=\"\", pattern=\"\")\n#     files =\n#         @chain begin\n#             map(walkdir(path)) do (root, dirs, files)\n#                 joinpath.(root, files)\n#             end\n#             reduce(vcat, _)\n#             filter(x -&gt; occursin(pattern, x), _)\n#         end\n\n#     files\n# end\n\n# arquivos = list_files(\"meshes/\", \".obj\")\n\n# arquivos = arquivos[1:5:80]\n\n# analises =\n#     @showprogress desc=\"lendo arquivo...\" map(arquivos) do file\n#         ms = read_mesh(file)\n#         pd, D, X, g = barcode_from_mesh(ms)\n#     end\n\n# analises[1]\n# barcode(analises[1][1])\n\n\n# arquivos = [\n#     \"meshes/flamingo-poses/flam-01.obj\"\n#     ,\"meshes/elephant-poses/elephant-01.obj\"\n# ]\n\n# analises = map(arquivos) do f\n#     ms = read_mesh(f)\n#     barcode_from_mesh(ms, 350)\n# end\n\n# pd, D, X, g = analises[1]\n# exc = mapslices(sum, D, dims=2) |&gt; vec\n# gl.scatter(X, color=exc)\n# barcode(pd)\n\n# pd, D, X, g = analises[2]\n# exc = mapslices(sum, D, dims=2) |&gt; vec\n# gl.scatter(X, color=exc)\n# barcode(pd)\n\n# Bottleneck()(analises[1][1][2:3], analises[2][1][2:3])",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#loading-and-visualizing-the-shapes",
    "href": "3d-shapes.html#loading-and-visualizing-the-shapes",
    "title": "2  3d shape classification using persistent homology",
    "section": "2.2 Loading and visualizing the shapes",
    "text": "2.2 Loading and visualizing the shapes\nLet’s start with a flamingo shape. We load some libraries\n\n# read meshes and plot\nusing Meshes, GeoIO\nimport GLMakie as gl\n\n# see progress\nusing ProgressMeter\n\n# dataframes\nusing DataFramesMeta, CSV, Chain\n\n# metric spaces and graphs\nusing MetricSpaces\nusing Graphs, SimpleWeightedGraphs\n\n# persistent homology\nimport Ripserer\nimport PersistenceDiagrams as Pd\nimport Plots\n\n# comparing the distance matrix\nusing Clustering, StatsPlots\n\nand define functions to read and visualize shapes\n\nread_mesh(filepath) = GeoIO.load(filepath).geometry\n\nplot_mesh(ms) = viz(ms);\n\nThe reference pose is the following:\n\nfilepath = \"meshes/flamingo-poses/flam-reference.obj\"\nms = read_mesh(filepath)\n\nplot_mesh(ms)\n\n\n\n\n\n\n\n\nWe can see some variations of it:\n\nms2 = read_mesh(\"meshes/flamingo-poses/flam-01.obj\")\n\nplot_mesh(ms2)\n\n\n\n\n\n\n\n\n\nms2 = read_mesh(\"meshes/flamingo-poses/flam-02.obj\")\n\nplot_mesh(ms2)\n\n\n\n\n\n\n\n\n\nms2 = read_mesh(\"meshes/flamingo-poses/flam-03.obj\")\n\nplot_mesh(ms2)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#setting-the-classification-problem",
    "href": "3d-shapes.html#setting-the-classification-problem",
    "title": "2  3d shape classification using persistent homology",
    "section": "2.3 Setting the classification problem",
    "text": "2.3 Setting the classification problem\nWe have 83 shapes in the following directories:\n\nfilter(!isfile, readdir(\"meshes/\", join = true))\n\n8-element Vector{String}:\n \"meshes/camel-poses\"\n \"meshes/cat-poses\"\n \"meshes/elephant-poses\"\n \"meshes/face-poses\"\n \"meshes/flamingo-poses\"\n \"meshes/head-poses\"\n \"meshes/horse-poses\"\n \"meshes/lion-poses\"\n\n\nEach shape \\(s \\in S\\) has a class of the type camel, cat, elephant, etc. We can think of these classes as a function \\(c: S \\to C\\) where \\(C\\) is the set of classes. Let \\(S_{rp}\\) be the set of reference poses.\nWe will try to solve the following problem: can we correctly calculate \\(c(s)\\) when we only know \\(c\\) for \\(s \\in S_{rp}\\)? That is: knowing only the class of each reference pose, can we deduce the class of the remaining shapes using only the mesh file?\nThis kind of problem is common in data science and is known as a “classification problem”: we are trying to atribute classes to objects, knowing the class of fewer other objects.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#from-meshes-to-metric-spaces",
    "href": "3d-shapes.html#from-meshes-to-metric-spaces",
    "title": "2  3d shape classification using persistent homology",
    "section": "2.4 From meshes to metric spaces",
    "text": "2.4 From meshes to metric spaces\nAs this is a minicourse on topological data analysis, we know that in somewhere we have to use persistent homology.\nAn ingenuous attempt to solve the classification problem can be summarised as follows:\n\nFor each shape \\(S_i\\), extract the points \\(X_i \\subset \\mathbb{R}^3\\) and consider \\(d\\) as the Euclidean distance;\nCalculate the persistence diagram \\(D_i = dgm(X_i)\\);\nFor each \\(D_i\\), calculate the bottleneck distance from \\(D_i\\) to all \\(D_j\\) where \\(S_j\\) is a reference pose;\nThe closest reference pose to \\(D_i\\) will be the class of \\(S_i\\).\n\nThis approach won’t work because of the two first steps:\n\nThe euclidean distance is not appropriate for this problem. Flamingos in different poses will have a big Gromov-Hausdorff distance. We need to use some kind of geodesic distance.\nThe amount of points in \\(X_i\\) is too big to calculate the persistence diagram. The flamingo dataset has more than 25.000 points for each shape. This will probably explode your RAM memory when calculating the Rips complex.\n\nFortunately, there are ways to contourn these problems!\n\nExtract a subset of “reasonably spaced points” of \\(S\\) that still contains its core geometric properties;\nCalculate the geodesic distance between these points using the shape \\(S\\).\n\n\n2.4.1 From meshes to \\(\\mathbb{R}^3\\)\nLet’s extract the points of \\(S\\) as a subspace of \\(\\mathbb{R}^3\\):\n\nmesh_to_metric_space(ms) = ms.vertices .|&gt; coordinates .|&gt; Vector |&gt; EuclideanSpace;\n\n\nX = mesh_to_metric_space(ms)\n\n26907-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-0.0497887, 0.179158, 0.304686]\n [-0.0478521, 0.176355, 0.337555]\n [-0.0489072, 0.170843, 0.36641]\n [-0.0479558, 0.154587, 0.319926]\n [-0.0484908, 0.148718, 0.356395]\n [-0.0549708, 0.129732, 0.300859]\n [-0.0529351, 0.125235, 0.325443]\n [-0.0537256, 0.124306, 0.346663]\n [-0.0569744, 0.201286, 0.371339]\n [-0.0536567, 0.19095, 0.297565]\n [-0.0522451, 0.191074, 0.306529]\n [-0.0571656, 0.181709, 0.282749]\n [-0.0524422, 0.185973, 0.296856]\n ⋮\n [-0.209925, 0.44, 0.658976]\n [-0.20707, 0.420017, 0.655563]\n [-0.210662, 0.444178, 0.660018]\n [-0.211038, 0.441635, 0.658588]\n [-0.208734, 0.420334, 0.651864]\n [-0.211586, 0.429432, 0.654244]\n [-0.210811, 0.425791, 0.653265]\n [-0.210709, 0.423044, 0.649643]\n [-0.211377, 0.439884, 0.657541]\n [-0.211205, 0.437203, 0.65695]\n [-0.211346, 0.434063, 0.656262]\n [-0.212218, 0.433793, 0.654967]\n\n\nWe can see that \\(X\\) is made of 26907 points of \\(\\mathbb{R}^3\\). We can plot it:\n\ngl.scatter(X, markersize = 1)\n\n\n\n\n\n\n\n\n\n\n2.4.2 From meshes to graphs\nNow, to calculate the geodesic distance, we will create a graph from the mesh \\(S\\). We load packages and define a function\n\n\nCode\nfunction graph_from_mesh(ms)\n    # the set of vertices\n    V = coordinates.(ms.vertices)\n\n    # create an empty graph\n    g = SimpleWeightedGraph()\n\n    # add n vertices to it\n    n = length(V)\n    add_vertices!(g, n)\n\n    # the set of triangles of the mesh ms\n    triangles = ms.topology.connec\n\n    # for each triangle, add its edges to the graph\n    @showprogress desc = \"Adding vertices to graph...\" for t ∈ triangles\n        v1, v2, v3 = t.indices\n        add_edge!(g, v1, v2, dist_euclidean(V[v1], V[v2]))\n        add_edge!(g, v1, v3, dist_euclidean(V[v1], V[v3]))\n        add_edge!(g, v2, v3, dist_euclidean(V[v2], V[v3]))\n    end\n\n    g\nend;\n\n\nand create the graph \\(g\\) from the mesh\n\ng = graph_from_mesh(ms)\n\n{26907, 79244} undirected simple Int64 graph with Float64 weights\n\n\nThis weighted graph is the 1-skeleton of the mesh, and the weights between the vertices are the euclidean distance between then (as subsets of \\(\\mathbb{R}^3\\)).\nWe can see the sparse array of its weight as follows:\n\nweights(g)\n\n26907×26907 SparseArrays.SparseMatrixCSC{Float64, Int64} with 158488 stored entries:\n⎡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣶⣶⣖⣆⣀⡀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠈⢋⠛⠿⡿⣿⣿⣾⣆⣀⡀⠀⠀⠀⠀⠀⠉⠛⠿⢤⡀⠀⠀⠈⠁⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠻⠿⠷⠷⣦⣀⡀⠀⠀⠀⠀⠀⠉⠙⠂⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠒⠠⠠⠄⡀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠳⢤⣄⣀⠀⠀⠀⠐⢦⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠐⠒⠀⠀⠀⠀⠀⠀⢀⡀⠀⠈⠉⠛⠳⠶⣤⣈⠙⎥\n⎢⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠰⣦⣤⣠⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠈⠉⠂⠀⠀⠀⠉⠛⎥\n⎢⢻⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⣻⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⢸⢿⡦⢀⠀⠀⢠⠀⠀⠀⠀⠐⠛⢿⢿⣷⣷⡤⡄⢐⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠈⢹⣿⡄⠀⠀⠀⡂⠀⠀⠀⠀⠀⠀⠙⡿⣿⣿⣷⣾⣄⢀⡀⠀⠀⠀⠀⠀⠀⠀⠑⣖⠂⠀⠀⠀⠀⠀⠂⠀⎥\n⎢⠀⢈⣿⣯⡀⠀⠀⠡⡀⠀⠀⠀⠀⠀⢀⢉⣹⣿⣿⣿⣼⣕⣀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢷⡄⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠈⣻⣿⣷⠀⠀⠀⢃⠀⠀⠀⠀⠀⠀⠀⠀⢙⢖⢿⣿⣿⣧⣲⣀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣄⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠈⢹⣿⡆⠀⠀⠘⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠘⢩⣻⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠹⣧⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠈⢽⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠙⢿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠈⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠻⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⢧⠀⠀⠀⠈⣧⠀⠀⢀⠀⠀⠈⠘⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣦⡄⠀⠀⠀⠀⠀⠀⢀⠀⠀⎥\n⎢⠀⠈⣧⠀⠀⠀⠙⣆⠀⠈⠆⠀⠀⠀⠀⠉⢱⢤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣦⡀⠀⠀⠀⠀⠘⢲⠀⎥\n⎢⠀⠀⠛⣇⠀⠀⠀⢹⡆⠀⡆⠀⠀⠀⠀⠀⠈⠀⠙⠷⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⢰⣀⎥\n⎢⠀⠀⠀⠈⣇⠀⠀⠀⢿⡀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠷⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠿⣧⣀⠀⠀⠙⎥\n⎢⠀⠀⡀⠀⠈⠀⢀⠀⠘⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⢀⣀⠀⠀⠀⠀⠘⠻⣦⡀⠀⎥\n⎣⠀⠀⠁⠀⠀⠀⠈⠓⣆⠘⣧⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠒⠐⢲⣄⠀⠀⠈⠻⣦⎦\n\n\nNotice, however, that the mesh is not connected! This can be seen with\n\nis_connected(g)\n\nfalse\n\n\nThese are the connected components of \\(g\\):\n\nconnected_components(g)\n\n514-element Vector{Vector{Int64}}:\n [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  26898, 26899, 26900, 26901, 26902, 26903, 26904, 26905, 26906, 26907]\n [4032]\n [4036]\n [4039]\n [4042]\n [4046]\n [4047]\n [4048]\n [4049]\n [4050]\n [4077]\n [4099]\n [4100]\n ⋮\n [7089]\n [7090]\n [7091]\n [7092]\n [7093]\n [7094]\n [7095]\n [7096]\n [7097]\n [7098]\n [7099]\n [7100]\n\n\nThere is one big connected components, and several smaller ones with 1 point each. Let’s extract the one with the most points and throw away the points of \\(X\\) outside it.\n\n\nCode\nfunction extract_biggest_connected_component(g)\n    cc_components = connected_components(g)\n    ids_biggest_component = cc_components[findmax(length, cc_components)[2]]\n\n    # modify the graph g on place\n    g = g[ids_biggest_component]\n\n    # return g and the ids of the biggest connected component\n    g, ids_biggest_component\nend;\n\n\n\ng, ids_biggest_component = extract_biggest_connected_component(g);\n\nWe can see that \\(g\\) now is connected:\n\nis_connected(g)\n\ntrue\n\n\nLet’s throw away from \\(X\\) the points outside this component:\n\nX = X[ids_biggest_component]\n\n26394-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-0.0497887, 0.179158, 0.304686]\n [-0.0478521, 0.176355, 0.337555]\n [-0.0489072, 0.170843, 0.36641]\n [-0.0479558, 0.154587, 0.319926]\n [-0.0484908, 0.148718, 0.356395]\n [-0.0549708, 0.129732, 0.300859]\n [-0.0529351, 0.125235, 0.325443]\n [-0.0537256, 0.124306, 0.346663]\n [-0.0569744, 0.201286, 0.371339]\n [-0.0536567, 0.19095, 0.297565]\n [-0.0522451, 0.191074, 0.306529]\n [-0.0571656, 0.181709, 0.282749]\n [-0.0524422, 0.185973, 0.296856]\n ⋮\n [-0.209925, 0.44, 0.658976]\n [-0.20707, 0.420017, 0.655563]\n [-0.210662, 0.444178, 0.660018]\n [-0.211038, 0.441635, 0.658588]\n [-0.208734, 0.420334, 0.651864]\n [-0.211586, 0.429432, 0.654244]\n [-0.210811, 0.425791, 0.653265]\n [-0.210709, 0.423044, 0.649643]\n [-0.211377, 0.439884, 0.657541]\n [-0.211205, 0.437203, 0.65695]\n [-0.211346, 0.434063, 0.656262]\n [-0.212218, 0.433793, 0.654967]\n\n\nWe now have 26394 points, which is a small reduction.\n\n\n2.4.3 Farthest points sampling\nWe could just select a random sample of points from our space, but points in high-density areas would be selected a lot more. There is another way to select points in a “well spaced manner”, called the farthest point sampling algorithm. This algorithm was shown to me by Facundo Mémoli on a dirty blackboard in 2018 and the simplicity of it astonished me. For the curious ones, the algorithm is detailed below.\n\n\n\n\n\n\nImportant\n\n\n\n\nLet \\((X, d)\\) be a metric space. Fix an integer \\(n\\). Let \\(C = \\emptyset\\) be the “set of chosen points”. Select \\(x_1 \\in X\\) randomly and add it to \\(C\\). Repeat the following procedure until you have \\(n\\) points in \\(C\\):\n\nCalculate the point \\(x \\in X\\) that is the most distant from all elements of \\(C\\), ie, \\[\n\\max \\{ d(x, c), c \\in C \\} = \\max \\{d(x', c), x' \\in X, c \\in C \\}.\n\\]\nAdd \\(x\\) to \\(C\\).\nIf \\(C\\) has \\(n\\) points, stop.\n\nThe set \\(C\\) is called a farthest points sampling of \\(X\\) with size \\(n\\).\nNotice that running the algorithm several times can lead to different sets \\(C\\) because the first term is chosen randomly.\n\n\nLet’s extract 400 points with the FPS algorithm and the euclidean distance:\n\nids_fps = farthest_points_sample(X, 400);\nX_fps = X[ids_fps]\n\n400-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-0.103327, 0.0494809, 0.353843]\n [-0.195649, 0.502407, 0.660994]\n [-0.270087, -0.46859, 0.403179]\n [-0.182738, 0.119117, 0.00595822]\n [-0.190263, 0.160414, 0.66562]\n [-0.113058, -0.240402, 0.304992]\n [-0.235742, 0.266743, 0.238924]\n [-0.131961, 0.274083, 0.45478]\n [-0.307364, 0.130389, 0.40441]\n [-0.245659, -0.0913953, 0.335295]\n [-0.0921687, 0.144702, 0.178859]\n [-0.0868923, -0.467545, 0.403375]\n [-0.18317, 0.437932, 0.496342]\n ⋮\n [-0.109168, -0.466482, 0.386587]\n [-0.209019, 0.492111, 0.613526]\n [-0.172134, 0.241533, 0.183956]\n [-0.183409, 0.0631612, 0.407425]\n [-0.126552, 0.101107, 0.145427]\n [-0.162374, 0.401511, 0.644509]\n [-0.0828722, 0.138331, 0.20497]\n [-0.140649, 0.0892385, 0.494259]\n [-0.110421, 0.140709, 0.111964]\n [-0.275791, 0.118022, 0.244702]\n [-0.124683, -0.288961, 0.308421]\n [-0.16147, 0.0476401, 0.314669]\n\n\n\ngl.scatter(X_fps, markersize = 10)\n\n\n\n\n\n\n\n\nThis is a very good approximation!\nWe are now interested in calculating the geodesic distance between these 400 points. But be careful! The geodesic distance need the entire mesh to work.\n\n\n2.4.4 Geodesic distances\nGiven a shape \\(S\\), we can think of the geodesic distance between two points as “the least distance an and would need to walk from one point to another”. We will approximate this “walkable” paths using the edges of the triangles of the shape \\(S\\). Remember: a mesh is a set of points and triangles!\nThe Dijkstra algorithm is perfect for our needs: it calculates the shortest path from one point to another in a weighted graph. So all we need is to:\n\nTransform \\(S\\) into a graph where the edges have weights (the euclidean distance between these points);\nCalculate the shortest path between each two points.\n\nWe already have the first item, so let’s calculate the second.\n\n\nCode\nfunction geodesic_distance_from_graph(g, ids)\n    n = length(ids)\n    D = zeros(n, n)\n\n    # for each point, calculate the distance from it to every other point of g\n    @showprogress desc = \"Calculating geodesic distance...\" Threads.@threads for (i, id) ∈ collect(enumerate(ids))\n        dts = dijkstra_shortest_paths(g, id)\n        D[i, :] = dts.dists[ids]\n    end\n\n    # force simmetry on X, because of small difference\n    # in the calculation of paths\n    for i ∈ 1:n\n        for j ∈ i:n\n            D[i, j] = D[j, i]\n        end\n    end\n\n    # normalize the distance so the max is 1\n    max_dist = maximum(D)\n    D = D ./ max_dist\n\n    return D\nend;\n\n\n\nD = geodesic_distance_from_graph(g, ids_fps)\n\n400×400 Matrix{Float64}:\n 0.0        0.530142   0.499246  0.264609   …  0.169238  0.240255   0.0547009\n 0.530142   0.0        0.918953  0.780164      0.606744  0.75228    0.552061\n 0.499246   0.918953   0.0       0.658898      0.503215  0.697101   0.451516\n 0.264609   0.780164   0.658898  0.0           0.182098  0.48602    0.233298\n 0.262727   0.315112   0.643909  0.504081      0.335992  0.484189   0.27567\n 0.207399   0.719488   0.664643  0.453252   …  0.351145  0.0362681  0.23138\n 0.290014   0.629392   0.62225   0.199074      0.136629  0.508306   0.251215\n 0.200872   0.484602   0.675425  0.357366      0.284508  0.439057   0.244894\n 0.188418   0.486468   0.489937  0.299234      0.120903  0.392601   0.154776\n 0.188249   0.611222   0.313753  0.34568       0.189996  0.386511   0.139964\n 0.149799   0.652296   0.582552  0.141795   …  0.174296  0.376649   0.138812\n 0.41567    0.926336   0.872173  0.663548      0.559896  0.180673   0.440744\n 0.432588   0.139475   0.824631  0.685955      0.51187   0.654725   0.45677\n ⋮                                          ⋱                       \n 0.4011     0.911766   0.857603  0.648978      0.545326  0.166103   0.426174\n 0.492035   0.0387736  0.881058  0.742268      0.568849  0.714173   0.514166\n 0.234718   0.688653   0.6593    0.158043   …  0.164659  0.467113   0.241419\n 0.0757014  0.483707   0.452269  0.29755       0.162539  0.284307   0.0696928\n 0.160759   0.679379   0.567907  0.108856      0.142185  0.384225   0.13162\n 0.516545   0.102699   0.911614  0.772825      0.599405  0.738683   0.540727\n 0.130241   0.632738   0.569834  0.159712      0.16775   0.35709    0.120392\n 0.112316   0.418502   0.52731   0.369315   …  0.234151  0.333778   0.136336\n 0.190622   0.701197   0.60596   0.0932597     0.17839   0.415693   0.167783\n 0.169238   0.606744   0.503215  0.182098      0.0       0.383603   0.121638\n 0.240255   0.75228    0.697101  0.48602       0.383603  0.0        0.263839\n 0.0547009  0.552061   0.451516  0.233298      0.121638  0.263839   0.0\n\n\nWe can see that \\(D\\) makes sense just by plotting \\(X_fps\\) colored by the sum of the distances to each points:\n\nexc = map(sum, eachcol(D))\n\ngl.scatter(X_fps, color = exc, markersize = 10)\n\n\n\n\n\n\n\n\nLooks good! The extremities of the flamingo are in a lighter color, indicating that the sum of the distances there is bigger. Now we have 1000 points sampled from \\(S\\), together with the geodesic distance.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#persistent-homology",
    "href": "3d-shapes.html#persistent-homology",
    "title": "2  3d shape classification using persistent homology",
    "section": "2.5 Persistent homology",
    "text": "2.5 Persistent homology\nWe can now calculate the persistence diagram of \\(X_fps\\) with the geodesic distance and use it! Let’s load some packages and calculate it\n\npd = Ripserer.ripserer(D, dim_max = 2, verbose=true, sparse = true, threshold = 0.8)\n\n3-element Vector{PersistenceDiagrams.PersistenceDiagram}:\n 400-element 0-dimensional PersistenceDiagram\n 202-element 1-dimensional PersistenceDiagram\n 15-element 2-dimensional PersistenceDiagram\n\n\nPloting the intervals looks as follows:\n\n\nCode\nfunction plot_barcode(pd)\n    # get the size of the longest interval\n    threshold = \n        @chain begin\n            vcat(pd...)\n            last.(_)\n            filter(isfinite, _)\n            maximum\n        end\n\n    # plot the barcode using this interval as the maximum value of the x-axis\n    Ripserer.barcode(pd, infinity = threshold)\nend;\n\n\n\nplot_barcode(pd)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nor just the 1- and 2-dimensional barcode:\n\nplot_barcode(pd[2:3])",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#summarizing",
    "href": "3d-shapes.html#summarizing",
    "title": "2  3d shape classification using persistent homology",
    "section": "2.6 Summarizing",
    "text": "2.6 Summarizing\nAll the hard work on the previous sections was just to prepare our dataset from file to barcode. That’s why they say that data science is 80% preparing the data and 20% analyzing it!\nWe can summarise what we did with the following function:\n\n\nCode\nfunction file_to_barcode(filepath; n_points = 1000, dim_max = 1)\n    ms = read_mesh(filepath)\n\n    X = mesh_to_metric_space(ms)\n    g = graph_from_mesh(ms)\n\n    g, ids_biggest_component = extract_biggest_connected_component(g)\n    X = X[ids_biggest_component]\n\n    ids_fps = farthest_points_sample(X, n_points);\n    X_fps = X[ids_fps]\n\n    D = geodesic_distance_from_graph(g, ids_fps)\n\n    pd = Ripserer.ripserer(D, dim_max = dim_max, verbose=true, sparse = true, threshold = 0.8)\n\n    return X_fps, D, pd\nend;\n\n\nWe also define some functions to save the barcodes and metric spaces to disk, so we don’t have to calculate all of them in a single session. Calculating the 2-dimensional barcode can take some time depending on your hardware!\n\n\nCode\nfunction pd_to_dataframe(pd)\n    df = @chain begin\n        map(pd) do p\n            DataFrame(\n                birth=p .|&gt; first, death=p .|&gt; last, dim=p.dim\n            )\n        end\n        vcat(_...)\n    end\n\n    df\nend\n\nfunction dataframe_to_pd(df)\n    df.threshold .= 1\n\n    @chain df begin\n        groupby(:dim)\n        collect\n        map(Pd.PersistenceDiagram, _)\n    end\nend\n\nfunction metric_space_to_df(X) \n    @chain X_fps begin\n        stack\n        transpose\n        DataFrame(_, :auto)\n    end\nend\n\nfunction list_files(path=\"\", pattern=\"\")\n    files =\n        @chain begin\n            map(walkdir(path)) do (root, dirs, files)\n                joinpath.(root, files)\n            end\n            reduce(vcat, _)\n            filter(x -&gt; occursin(pattern, x), _)\n        end\n\n    files\nend;\n\n\nNow we loop over all meshes, calculate its persistence diagram and save it to disk, together with the \\(X_fps\\) metric space as above.\nImportant: This can take some time! If you cloned my github repository, these files are already there, so you can skip the following piece of code:\n\noverwrite_old_files = true\n\n@showprogress \"Calculating barcode...\" for file ∈ list_files(\"meshes/\", \".obj\") \n    println(\"Calculating barcode from file $file ...\")\n\n    file_pd = replace(file, \".obj\" =&gt; \"-pd.csv\")\n    # skip if there is a file already\n    if isfile(file_pd) & !overwrite_old_files continue end\n\n    X_fps, D, pd = file_to_barcode(file, n_points = 350, dim_max = 2)\n    df = pd_to_dataframe(pd)\n\n    CSV.write(file_pd, df)\n\n    file_X = replace(file, \".obj\" =&gt; \"-points.csv\")\n    CSV.write(file_X, metric_space_to_df(X_fps))\nend\n\nWe read the persistence diagrams saved on disk and pass them to table (a DataFrame object), but first we throw away small intervals.\n\n\nCode\nfunction throw_away_small_intervals(pd, min_pers = 0.01)\n    map(pd) do p\n        filter(x -&gt; Pd.persistence(x) &gt; min_pers, p)\n    end\nend;\n\n\n\n\nCode\nfunction read_pds_from_files(directory, min_interval_size = 0.05)\n  pds_df = DataFrame()\n\n#   file = list_files(\"meshes/\", \"-pd.csv\")[1]\n  for file ∈ list_files(directory, \"-pd.csv\")\n\n      pd = @chain begin\n          CSV.read(file, DataFrame)\n          dataframe_to_pd(_)\n          throw_away_small_intervals(min_interval_size)\n      end\n\n      name = replace(file, \"-pd.csv\" =&gt; \"\")\n      push!(pds_df, (Path = name, Persistence_diagram = pd))\n  end\n\n  pds_df\n\n  sort!(pds_df, :Path)\n\n  pds_df.File = [split(s, \"/\")[3] for s ∈ pds_df.Path]\n  pds_df.Class = [split(s, \"-\")[1] for s ∈ pds_df.File]\n\n  pds_df\nend;\n\n\n\npds_df = read_pds_from_files(\"meshes/\", 0.01)\n\n83×4 DataFrame58 rows omitted\n\n\n\nRow\nPath\nPersistence_diagram\nFile\nClass\n\n\n\nString\nArray…\nSubStrin…\nSubStrin…\n\n\n\n\n1\nmeshes/camel-poses/camel-01\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 64-element 1-dimensional PersistenceDiagram, 2-element 2-dimensional PersistenceDiagram]\ncamel-01\ncamel\n\n\n2\nmeshes/camel-poses/camel-02\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 62-element 1-dimensional PersistenceDiagram, 5-element 2-dimensional PersistenceDiagram]\ncamel-02\ncamel\n\n\n3\nmeshes/camel-poses/camel-03\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 79-element 1-dimensional PersistenceDiagram, 2-element 2-dimensional PersistenceDiagram]\ncamel-03\ncamel\n\n\n4\nmeshes/camel-poses/camel-04\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 75-element 1-dimensional PersistenceDiagram, 3-element 2-dimensional PersistenceDiagram]\ncamel-04\ncamel\n\n\n5\nmeshes/camel-poses/camel-05\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 68-element 1-dimensional PersistenceDiagram, 2-element 2-dimensional PersistenceDiagram]\ncamel-05\ncamel\n\n\n6\nmeshes/camel-poses/camel-06\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 71-element 1-dimensional PersistenceDiagram, 2-element 2-dimensional PersistenceDiagram]\ncamel-06\ncamel\n\n\n7\nmeshes/camel-poses/camel-07\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 78-element 1-dimensional PersistenceDiagram, 4-element 2-dimensional PersistenceDiagram]\ncamel-07\ncamel\n\n\n8\nmeshes/camel-poses/camel-08\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 73-element 1-dimensional PersistenceDiagram, 4-element 2-dimensional PersistenceDiagram]\ncamel-08\ncamel\n\n\n9\nmeshes/camel-poses/camel-09\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 83-element 1-dimensional PersistenceDiagram, 5-element 2-dimensional PersistenceDiagram]\ncamel-09\ncamel\n\n\n10\nmeshes/camel-poses/camel-10\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 79-element 1-dimensional PersistenceDiagram, 3-element 2-dimensional PersistenceDiagram]\ncamel-10\ncamel\n\n\n11\nmeshes/camel-poses/camel-reference\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 70-element 1-dimensional PersistenceDiagram, 5-element 2-dimensional PersistenceDiagram]\ncamel-reference\ncamel\n\n\n12\nmeshes/cat-poses/cat-01\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 87-element 1-dimensional PersistenceDiagram, 11-element 2-dimensional PersistenceDiagram]\ncat-01\ncat\n\n\n13\nmeshes/cat-poses/cat-02\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 73-element 1-dimensional PersistenceDiagram, 10-element 2-dimensional PersistenceDiagram]\ncat-02\ncat\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n72\nmeshes/horse-poses/horse-09\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 68-element 1-dimensional PersistenceDiagram, 11-element 2-dimensional PersistenceDiagram]\nhorse-09\nhorse\n\n\n73\nmeshes/horse-poses/horse-10\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 85-element 1-dimensional PersistenceDiagram, 11-element 2-dimensional PersistenceDiagram]\nhorse-10\nhorse\n\n\n74\nmeshes/lion-poses/lion-01\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 85-element 1-dimensional PersistenceDiagram, 12-element 2-dimensional PersistenceDiagram]\nlion-01\nlion\n\n\n75\nmeshes/lion-poses/lion-02\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 91-element 1-dimensional PersistenceDiagram, 14-element 2-dimensional PersistenceDiagram]\nlion-02\nlion\n\n\n76\nmeshes/lion-poses/lion-03\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 104-element 1-dimensional PersistenceDiagram, 21-element 2-dimensional PersistenceDiagram]\nlion-03\nlion\n\n\n77\nmeshes/lion-poses/lion-04\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 96-element 1-dimensional PersistenceDiagram, 13-element 2-dimensional PersistenceDiagram]\nlion-04\nlion\n\n\n78\nmeshes/lion-poses/lion-05\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 87-element 1-dimensional PersistenceDiagram, 14-element 2-dimensional PersistenceDiagram]\nlion-05\nlion\n\n\n79\nmeshes/lion-poses/lion-06\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 91-element 1-dimensional PersistenceDiagram, 13-element 2-dimensional PersistenceDiagram]\nlion-06\nlion\n\n\n80\nmeshes/lion-poses/lion-07\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 90-element 1-dimensional PersistenceDiagram, 12-element 2-dimensional PersistenceDiagram]\nlion-07\nlion\n\n\n81\nmeshes/lion-poses/lion-08\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 101-element 1-dimensional PersistenceDiagram, 10-element 2-dimensional PersistenceDiagram]\nlion-08\nlion\n\n\n82\nmeshes/lion-poses/lion-09\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 98-element 1-dimensional PersistenceDiagram, 15-element 2-dimensional PersistenceDiagram]\nlion-09\nlion\n\n\n83\nmeshes/lion-poses/lion-reference\nPersistenceDiagram[350-element 0-dimensional PersistenceDiagram, 97-element 1-dimensional PersistenceDiagram, 13-element 2-dimensional PersistenceDiagram]\nlion-reference\nlion\n\n\n\n\n\n\nThe dataframe looks ok! You can plot the barcodes as follows:\n\npd2 = pds_df.Persistence_diagram[1]\nplot_barcode(pd2[2:3])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we calculate the bootleneck distance between each pair of persistence diagrams. This can take some time! If you cloned the repository, you don’t need to run this piece of code.\n\npds = pds_df.Persistence_diagram\n\nDB = zeros(83, 83)\n\n@showprogress for i ∈ 1:83\n    for j ∈ i:83\n        if i == j\n            DB[i, j] = 0 \n            continue \n        end\n\n        DB[i, j] = \n            Pd.Bottleneck()(pds[i][2], pds[j][2]) + \n            Pd.Bottleneck()(pds[i][3], pds[j][3])\n\n        DB[j, i] = DB[i, j]\n    end\nend\n\nCSV.write(\"meshes/bottleneck_distance.csv\", DataFrame(DB, :auto))\n\nNotice that we defined the distance \\(DB_{i, j}\\) between two shapes \\(X_i\\) and \\(X_j\\) as\n\\[\nDB_{i, j} = d_b(dgm_1(X_i), dgm_1(X_j)) + d_b(dgm_2(X_i), dgm_2(X_j))\n\\]\nwhere \\(d_b\\) is the bottleneck distance, and \\(dgm_i\\) is the \\(i\\)-dimensional persistence diagram.\nWe read \\(DB\\) from disk, in case you did not calculate it previously\n\nDB = CSV.read(\"meshes/bottleneck_distance.csv\", DataFrame) |&gt; Matrix\nDB\n\n83×83 Matrix{Float64}:\n 0.0        0.0295622  0.0290437  …  0.0607949  0.0572987  0.0555027\n 0.0295622  0.0        0.0243571     0.0771963  0.0725624  0.0726897\n 0.0290437  0.0243571  0.0           0.0751122  0.0706953  0.07074\n 0.0250842  0.0221888  0.0246823     0.0699059  0.0653315  0.0658234\n 0.0192733  0.0247452  0.0230421     0.0647476  0.062099   0.0607826\n 0.0300337  0.0257192  0.014413   …  0.0729532  0.0680901  0.0688222\n 0.0270758  0.0372715  0.0355232     0.0541806  0.0491843  0.0458797\n 0.0239714  0.0229871  0.0240051     0.0654462  0.0644016  0.0613805\n 0.0354928  0.0229931  0.0236201     0.0807913  0.0765014  0.0759065\n 0.0282784  0.0247452  0.0209122     0.0744052  0.0719081  0.0700331\n 0.0242075  0.0255816  0.0278271  …  0.0672653  0.0677038  0.0630916\n 0.0671795  0.0780996  0.0795003     0.0520017  0.0460498  0.0740998\n 0.0622585  0.076908   0.0745496     0.0303738  0.0299614  0.0425986\n ⋮                                ⋱  ⋮                     \n 0.0565404  0.0753205  0.0781827     0.0349974  0.0455993  0.0281456\n 0.053006   0.0704997  0.0687614     0.0305132  0.0366311  0.0263213\n 0.0745802  0.0753067  0.0726818     0.0587221  0.0524114  0.0815307\n 0.0505002  0.0651497  0.0599707     0.0282434  0.0248999  0.0497492\n 0.055084   0.0697334  0.0664574  …  0.0302786  0.0304893  0.0361665\n 0.0601642  0.0705143  0.066331      0.0346506  0.0309857  0.0538022\n 0.0512327  0.06873    0.0667174     0.0254585  0.0252535  0.0252038\n 0.0504608  0.0675057  0.0672269     0.0248009  0.0211124  0.0363764\n 0.061205   0.0701361  0.0729084     0.0441923  0.0406347  0.066897\n 0.0607949  0.0771963  0.0751122  …  0.0        0.0247205  0.0250417\n 0.0572987  0.0725624  0.0706953     0.0247205  0.0        0.0356727\n 0.0555027  0.0726897  0.07074       0.0250417  0.0356727  0.0\n\n\n\nlabels = pds_df.Class |&gt; copy\nfor i ∈ 2:length(pds_df.Class)\n    if labels[i] == pds_df.Class[i-1]\n        labels[i] = \"\"\n    end\nend\n\nlabels = (1:83, labels)\n\nplot(DB, st = :heatmap, xticks = labels, yticks = labels)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  }
]