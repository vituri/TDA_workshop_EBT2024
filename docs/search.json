[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TDA Workshop - EBT 2024",
    "section": "",
    "text": "1 Intro\nTo be done!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Intro</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html",
    "href": "3d-shapes.html",
    "title": "2  3d shape classification using persistent homology",
    "section": "",
    "text": "2.1 The dataset\nThe dataset we are using is !!!citar. It consists of !!!. The files can be downloaded at !!!. After downloading it, unzip the file and put then inside a directory called “meshes”. !!! jogou fora gallopes\nThe files are written in the “.obj” format. They are meshes: sets of points and triangles that forma 3d image like the ones we can see in videogames.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#loading-some-libraries",
    "href": "3d-shapes.html#loading-some-libraries",
    "title": "2  3d shape classification using persistent homology",
    "section": "3.1 Loading some libraries",
    "text": "3.1 Loading some libraries\n\nusing Meshes, GeoIO\nimport GLMakie as gl\nimport DelimitedFiles\nusing ProgressMeter\n\nusing Graphs, SimpleWeightedGraphs\nusing MetricSpaces, Ripserer, PersistenceDiagrams\nusing Chain\n\n\n# functions\nfunction reduz_obj(arquivo, n_points=1000)\n    geotable = GeoIO.load(arquivo)\n\n    X_total = geotable.vertices .|&gt; coordinates .|&gt; Vector |&gt; EuclideanSpace\n\n    ids = farthest_points_sample(X_total, n_points)\n    X = X_total[ids]\n\n    arquivo_novo = replace(arquivo, \".obj\" =&gt; \".csv\")\n    DelimitedFiles.writedlm(arquivo_novo, stack(X)' |&gt; Matrix, \",\")\n\n    X\nend\n\nfunction meshes_to_csv(dir_path)\n    for (root, dirs, files) ∈ collect(walkdir(dir_path))\n        for file ∈ files\n            if occursin(\".obj\", file)\n                arquivo = joinpath(root, file)\n                println(arquivo)\n                reduz_obj(arquivo)\n            end\n        end\n    end\nend\n\nread_mesh(arquivo) = GeoIO.load(arquivo).geometry\n\nfunction mesh_to_graph(ms, X)\n    g = SimpleWeightedGraph()\n    n = length(X)\n    add_vertices!(g, n)\n\n    triangles = ms.topology.connec\n\n    @showprogress desc = \"Adding vertices to graph...\" for t ∈ triangles\n        v1, v2, v3 = t.indices\n        add_edge!(g, v1, v2, dist_euclidean(X[v1], X[v2]))\n\n        add_edge!(g, v1, v3, dist_euclidean(X[v1], X[v3]))\n\n        add_edge!(g, v2, v3, dist_euclidean(X[v2], X[v3]))\n    end\n\n    g\nend\n\nmesh_to_metric_space(ms) = ms.vertices .|&gt; coordinates .|&gt; Vector |&gt; EuclideanSpace\n\nfunction geodesic_distance_from_graph(g, ids)\n    n = length(ids)\n    D = zeros(n, n)\n\n    @showprogress desc = \"Calculating geodesic distance...\" Threads.@threads for (i, id) ∈ collect(enumerate(ids))\n        dts = dijkstra_shortest_paths(g, id)\n        D[i, :] = dts.dists[ids]\n    end\n\n    return D\nend\n\nplot_mesh(ms) = viz(ms);\n\n\nms = read_mesh(\"meshes/flamingo-poses/flam-01.obj\")\n# ms = GeoIO.load(\"meshes/flamingo-poses/flam-01.obj\")\n\nplot_mesh(ms)\n\n┌ Warning: Found `resolution` in the theme when creating a `Scene`. The `resolution` keyword for `Scene`s and `Figure`s has been deprecated. Use `Figure(; size = ...` or `Scene(; size = ...)` instead, which better reflects that this is a unitless size and not a pixel resolution. The key could also come from `set_theme!` calls or related theming functions.\n└ @ Makie ~/.julia/packages/Makie/VRavR/src/scenes.jl:220\n\n\n\n\n\n\n# # componentes\n# function barcode_from_mesh(ms, n_points=1000)\n#     X_total = mesh_to_metric_space(ms)\n\n#     g = mesh_to_graph(ms, X_total)\n\n#     componentes_g = connected_components(g)\n#     ids_maior_componente = componentes_g[findmax(length, componentes_g)[2]]\n\n#     X_total = X_total[ids_maior_componente]\n\n#     g = g[ids_maior_componente]\n\n\n#     fts_sample = farthest_points_sample(X_total, n_points)\n#     X = X_total[fts_sample]\n#     D = geodesic_distance_from_graph(g, fts_sample)\n\n#     # force simmetry on X\n#     for i ∈ 1:n_points\n#         for j ∈ i:n_points\n#             D[i, j] = D[j, i]\n#         end\n#     end\n\n#     max_dist = maximum(D)\n#     D = D ./ max_dist\n\n#     pd = ripserer(D, dim_max = 2, verbose=true, sparse = true, threshold = 0.9)\n\n#     pd, D, X, g\n\n# end\n\n# pd, D, X, g = barcode_from_mesh(ms, 300)\n\n# exc = mapslices(sum, D, dims=2) |&gt; vec\n\n# gl.scatter(X, color=exc)\n\n# import Plots\n# Plots.plot(pd)\n# barcode(pd)\n\n\n# calcula pds\n# function list_files(path=\"\", pattern=\"\")\n#     files =\n#         @chain begin\n#             map(walkdir(path)) do (root, dirs, files)\n#                 joinpath.(root, files)\n#             end\n#             reduce(vcat, _)\n#             filter(x -&gt; occursin(pattern, x), _)\n#         end\n\n#     files\n# end\n\n# arquivos = list_files(\"meshes/\", \".obj\")\n\n# arquivos = arquivos[1:5:80]\n\n# analises =\n#     @showprogress desc=\"lendo arquivo...\" map(arquivos) do file\n#         ms = read_mesh(file)\n#         pd, D, X, g = barcode_from_mesh(ms)\n#     end\n\n# analises[1]\n# barcode(analises[1][1])\n\n\n# arquivos = [\n#     \"meshes/flamingo-poses/flam-01.obj\"\n#     ,\"meshes/elephant-poses/elephant-01.obj\"\n# ]\n\n# analises = map(arquivos) do f\n#     ms = read_mesh(f)\n#     barcode_from_mesh(ms, 350)\n# end\n\n# pd, D, X, g = analises[1]\n# exc = mapslices(sum, D, dims=2) |&gt; vec\n# gl.scatter(X, color=exc)\n# barcode(pd)\n\n# pd, D, X, g = analises[2]\n# exc = mapslices(sum, D, dims=2) |&gt; vec\n# gl.scatter(X, color=exc)\n# barcode(pd)\n\n# Bottleneck()(analises[1][1][2:3], analises[2][1][2:3])",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#loading-and-visualizing-the-shapes",
    "href": "3d-shapes.html#loading-and-visualizing-the-shapes",
    "title": "2  3d shape classification using persistent homology",
    "section": "2.2 Loading and visualizing the shapes",
    "text": "2.2 Loading and visualizing the shapes\nLet’s start with a flamingo shape. We load some libraries\n\nusing Meshes, GeoIO\nimport GLMakie as gl\nusing ProgressMeter\n\nand define functions\n\nread_mesh(filepath) = GeoIO.load(filepath).geometry\n\nplot_mesh(ms) = viz(ms);\n\nThe reference pose is the following:\n\nfilepath = \"meshes/flamingo-poses/flam-reference.obj\"\nms = read_mesh(filepath)\n\nplot_mesh(ms)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#setting-the-classification-problem",
    "href": "3d-shapes.html#setting-the-classification-problem",
    "title": "2  3d shape classification using persistent homology",
    "section": "2.3 Setting the classification problem",
    "text": "2.3 Setting the classification problem\nWe have 83 shapes on the following directories:\n\nreaddir(\"meshes/\")\n\n8-element Vector{String}:\n \"camel-poses\"\n \"cat-poses\"\n \"elephant-poses\"\n \"face-poses\"\n \"flamingo-poses\"\n \"head-poses\"\n \"horse-poses\"\n \"lion-poses\"\n\n\nEach shape \\(s \\in S\\) has a class of the type camel, cat, elephant, etc. We can think of this class as a function \\(c: S \\to C\\) where \\(C\\) is the set of classes. Let \\(S_{rp}\\) be the set of reference poses.\nWe will try to solve the following problem: can we correctly calculate \\(c(s)\\) when we only know \\(c\\) for \\(s \\in S_{rp}\\)? That is: knowing only the class of each reference pose, can we deduce the class of the remaining shapes using only the mesh file?\nThis kind of problem is common in data science, and is known as a “classification problem”: we are trying to atribute classes to objects, knowing the class of fewer other objects.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  },
  {
    "objectID": "3d-shapes.html#from-meshes-to-metric-spaces",
    "href": "3d-shapes.html#from-meshes-to-metric-spaces",
    "title": "2  3d shape classification using persistent homology",
    "section": "2.4 From meshes to metric spaces",
    "text": "2.4 From meshes to metric spaces\nAs this is a minicourse on topological data analysis, we know that in somewhere we have to use persistent homology.\nAn ingenuous attempt to solve the classification problem can be summarised as follows:\n\nFor each shape \\(S_i\\), extract the points \\(X_i \\subset \\mathbb{R}^3\\) and consider \\(d\\) as the Euclidean distance;\nCalculate the persistence diagram \\(D_i = dgm(X_i)\\);\nFor each \\(D_i\\), calculate the bottleneck distance from \\(D_i\\) to all \\(D_j\\) where \\(S_j\\) is a reference pose;\nThe closest reference pose to \\(D_i\\) will be the class of \\(S_i\\).\n\nThis approach won’t work because of the two first steps.\n\nThe euclidean distance is not appropriate for this problem. Flamingos in different poses will have a big Gromov-Hausdorff distance. We need to use some kind of geodesic distance.\nThe amount of points in \\(X_i\\) is too big to calculate the persistence diagram. The flamingo dataset has more than 25.000 points for each shape. This will probably explode your RAM memory when calculating the Rips complex.\n\nFortunately, there are ways to contourn these problems!\n\nExtract a subset of “reasonably spaced points” of \\(S\\) that still contains its core geometric properties;\nCalculate the geodesic distance between these points using the shape \\(S\\).\n\n\n2.4.1 From meshes to \\(\\mathbb{R}^3\\)\nLet’s extract the points of \\(S\\) as a subspace of \\(\\mathbb{R}^3\\):\n\nusing MetricSpaces\n\nmesh_to_metric_space(ms) = ms.vertices .|&gt; coordinates .|&gt; Vector |&gt; EuclideanSpace\n\nmesh_to_metric_space (generic function with 1 method)\n\n\n\nX = mesh_to_metric_space(ms)\n\n26907-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-0.0497887, 0.179158, 0.304686]\n [-0.0478521, 0.176355, 0.337555]\n [-0.0489072, 0.170843, 0.36641]\n [-0.0479558, 0.154587, 0.319926]\n [-0.0484908, 0.148718, 0.356395]\n [-0.0549708, 0.129732, 0.300859]\n [-0.0529351, 0.125235, 0.325443]\n [-0.0537256, 0.124306, 0.346663]\n [-0.0569744, 0.201286, 0.371339]\n [-0.0536567, 0.19095, 0.297565]\n [-0.0522451, 0.191074, 0.306529]\n [-0.0571656, 0.181709, 0.282749]\n [-0.0524422, 0.185973, 0.296856]\n ⋮\n [-0.209925, 0.44, 0.658976]\n [-0.20707, 0.420017, 0.655563]\n [-0.210662, 0.444178, 0.660018]\n [-0.211038, 0.441635, 0.658588]\n [-0.208734, 0.420334, 0.651864]\n [-0.211586, 0.429432, 0.654244]\n [-0.210811, 0.425791, 0.653265]\n [-0.210709, 0.423044, 0.649643]\n [-0.211377, 0.439884, 0.657541]\n [-0.211205, 0.437203, 0.65695]\n [-0.211346, 0.434063, 0.656262]\n [-0.212218, 0.433793, 0.654967]\n\n\nWe can see that \\(X\\) is made of 26907 points of \\(\\mathbb{R}^3\\). We can plot it:\n\ngl.scatter(X, markersize = 5)\n\n\n\n\n\n\n2.4.2 From meshes to graphs\nNow, to calculate the geodesic distance, we will create a graph from the mesh \\(S\\).\n\nusing Graphs, SimpleWeightedGraphs\n\nfunction graph_from_mesh(ms)\n    # the set of vertices\n    V = coordinates.(ms.vertices)\n\n    # create an empty graph\n    g = SimpleWeightedGraph()\n\n    # add n vertices to it\n    n = length(V)\n    add_vertices!(g, n)\n\n    # the set of triangles of the mesh ms\n    triangles = ms.topology.connec\n\n    # for each triangle, add its edges to the graph\n    @showprogress desc = \"Adding vertices to graph...\" for t ∈ triangles\n        v1, v2, v3 = t.indices\n        add_edge!(g, v1, v2, dist_euclidean(V[v1], V[v2]))\n        add_edge!(g, v1, v3, dist_euclidean(V[v1], V[v3]))\n        add_edge!(g, v2, v3, dist_euclidean(V[v2], V[v3]))\n    end\n\n    g\nend;\n\nCalculate the graph \\(g\\) from the mesh\n\ng = graph_from_mesh(ms)\n\n{26907, 79244} undirected simple Int64 graph with Float64 weights\n\n\n\nNotice, however, that the mesh is not connected! This can be seen with\n\nis_connected(g)\n\nfalse\n\n\nThese are the connected components of \\(g\\):\n\nconnected_components(g)\n\n514-element Vector{Vector{Int64}}:\n [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  26898, 26899, 26900, 26901, 26902, 26903, 26904, 26905, 26906, 26907]\n [4032]\n [4036]\n [4039]\n [4042]\n [4046]\n [4047]\n [4048]\n [4049]\n [4050]\n [4077]\n [4099]\n [4100]\n ⋮\n [7089]\n [7090]\n [7091]\n [7092]\n [7093]\n [7094]\n [7095]\n [7096]\n [7097]\n [7098]\n [7099]\n [7100]\n\n\nLet’s extract the one with the most points and throw away the points of \\(X\\) outside it.\n\nfunction extract_biggest_connected_component(g)\n    cc_components = connected_components(g)\n    ids_biggest_component = cc_components[findmax(length, cc_components)[2]]\n\n    # modify the graph g on place\n    g = g[ids_biggest_component]\n\n    # return the ids of the biggest connected component\n    g, ids_biggest_component\nend\n\nextract_biggest_connected_component (generic function with 1 method)\n\n\n\ng, ids_biggest_component = extract_biggest_connected_component(g);\n\nWe can see that \\(g\\) now is connected:\n\nis_connected(g)\n\ntrue\n\n\nLet’s throw away from \\(X\\) the points outside this component:\n\nX = X[ids_biggest_component]\n\n26394-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-0.0497887, 0.179158, 0.304686]\n [-0.0478521, 0.176355, 0.337555]\n [-0.0489072, 0.170843, 0.36641]\n [-0.0479558, 0.154587, 0.319926]\n [-0.0484908, 0.148718, 0.356395]\n [-0.0549708, 0.129732, 0.300859]\n [-0.0529351, 0.125235, 0.325443]\n [-0.0537256, 0.124306, 0.346663]\n [-0.0569744, 0.201286, 0.371339]\n [-0.0536567, 0.19095, 0.297565]\n [-0.0522451, 0.191074, 0.306529]\n [-0.0571656, 0.181709, 0.282749]\n [-0.0524422, 0.185973, 0.296856]\n ⋮\n [-0.209925, 0.44, 0.658976]\n [-0.20707, 0.420017, 0.655563]\n [-0.210662, 0.444178, 0.660018]\n [-0.211038, 0.441635, 0.658588]\n [-0.208734, 0.420334, 0.651864]\n [-0.211586, 0.429432, 0.654244]\n [-0.210811, 0.425791, 0.653265]\n [-0.210709, 0.423044, 0.649643]\n [-0.211377, 0.439884, 0.657541]\n [-0.211205, 0.437203, 0.65695]\n [-0.211346, 0.434063, 0.656262]\n [-0.212218, 0.433793, 0.654967]\n\n\n\n\n2.4.3 Farthest points sampling\nWe could just select a random sample of points from our space, but !!!\nThe farthest points algorithm was shown to me by Facundo Mémoli on a dirty blackboard in 2018 !!!\n\n\n\n\n\n\nImportant\n\n\n\n\nLet \\((X, d)\\) be a metric space. Fix an integer \\(n\\). Let \\(C = \\emptyset\\) be a set of chosen points. Select \\(x_1 \\in X\\) and add it to \\(C\\). Repeat the following procedure until you have \\(n\\) points:\n\nCalculate the point \\(x \\in X\\) that is the most distant from all elements of \\(C\\).\nAdd \\(x\\) to \\(C\\).\nIf \\(C\\) has \\(n\\) points, stop.\n\nThe set \\(C\\) is called a farthest points sampling of \\(X\\) with size \\(n\\).\n\n\nLet’s extract 1000 points with the FPS algorithm:\n\nids_fps = farthest_points_sample(X, 1000);\nX_fps = X[ids_fps]\n\n1000-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-0.102398, 0.0541409, 0.354141]\n [-0.195649, 0.502407, 0.660994]\n [-0.270087, -0.46859, 0.403179]\n [-0.182738, 0.119117, 0.00595822]\n [-0.182755, 0.16202, 0.667542]\n [-0.11117, -0.236885, 0.306592]\n [-0.237924, 0.263987, 0.234966]\n [-0.131961, 0.274083, 0.45478]\n [-0.309222, 0.13766, 0.407333]\n [-0.24547, -0.0887498, 0.338711]\n [-0.0921687, 0.144702, 0.178859]\n [-0.0868923, -0.467545, 0.403375]\n [-0.246744, 0.0822468, 0.249545]\n ⋮\n [-0.0669232, 0.139089, 0.247815]\n [-0.0739433, 0.0941305, 0.292223]\n [-0.0881461, 0.242808, 0.403388]\n [-0.122151, -0.39803, 0.322502]\n [-0.213894, 0.250727, 0.213494]\n [-0.0968953, 0.234423, 0.471918]\n [-0.0571588, 0.118512, 0.353022]\n [-0.143286, 0.467641, 0.6377]\n [-0.183163, 0.456243, 0.591707]\n [-0.221069, 0.0889533, 0.167673]\n [-0.294464, 0.0927223, 0.304625]\n [-0.155312, -0.468422, 0.391171]\n\n\n\ngl.scatter(X_fps, markersize = 5)\n\n\n\n\nThis is a very reasonable approximation!\nWe are now interested in calculating the geodesic distance between these 1000 points. But be careful! The geodesic distance need the entire mesh to work.\n\n\n2.4.4 Geodesic distances\nGiven a shape \\(S\\), we can think of the geodesic distance between two points as “the least distance an and would need to walk from one point to another”. We will approximate this “walkable” paths using the edges of the triangles of the shape \\(S\\). Remember: a mesh is a set of points and triangles!\nThe Dijkstra algorithm is perfect for our needs: it calculates the shortest path from one point to another in a weighted graph. So all we need is to:\n\nTransform \\(S\\) into a graph where the edges have weights (the euclidean distance between these points);\nCalculate the shortest path between each two points.\n\n\nfunction geodesic_distance_from_graph(g, ids)\n    n = length(ids)\n    D = zeros(n, n)\n\n    @showprogress desc = \"Calculating geodesic distance...\" Threads.@threads for (i, id) ∈ collect(enumerate(ids))\n        dts = dijkstra_shortest_paths(g, id)\n        D[i, :] = dts.dists[ids]\n    end\n\n    # force simmetry on X, because of small difference\n    # in the calculation of paths\n    for i ∈ 1:n\n        for j ∈ i:n\n            D[i, j] = D[j, i]\n        end\n    end\n\n    # normalize the distance\n    max_dist = maximum(D)\n    D = D ./ max_dist\n\n    return D\nend\n\ngeodesic_distance_from_graph (generic function with 1 method)\n\n\n\nD = geodesic_distance_from_graph(g, ids_fps)\n\n1000×1000 Matrix{Float64}:\n 0.0        0.525173   0.498115  0.264095  …  0.163722   0.158548   0.402445\n 0.525173   0.0        0.915987  0.777645     0.663498   0.557259   0.908204\n 0.498115   0.915987   0.0       0.656771     0.538541   0.465152   0.854216\n 0.264095   0.777645   0.656771  0.0          0.11823    0.228057   0.646264\n 0.255194   0.314019   0.64573   0.506354     0.39372    0.289043   0.637551\n 0.20752    0.714522   0.66003   0.449322  …  0.346965   0.324789   0.202042\n 0.288612   0.629513   0.619678  0.195475     0.161937   0.157045   0.666684\n 0.196965   0.483038   0.673244  0.356212     0.329465   0.268467   0.596475\n 0.191454   0.483434   0.493864  0.300496     0.193218   0.0806295  0.555343\n 0.186457   0.606328   0.314568  0.342573     0.224343   0.151544   0.542989\n 0.149257   0.650191   0.580672  0.141337  …  0.120142   0.197467   0.537211\n 0.417586   0.923346   0.869358  0.661406     0.558766   0.535334   0.0559521\n 0.134464   0.599567   0.475402  0.182472     0.0657069  0.0532333  0.509712\n ⋮                                         ⋱                        \n 0.104001   0.599424   0.56281   0.190468     0.139243   0.194004   0.499643\n 0.0585343  0.568035   0.522898  0.222572     0.144504   0.171042   0.454176\n 0.161118   0.508138   0.637647  0.310222  …  0.276816   0.302103   0.560878\n 0.314558   0.8207     0.766713  0.558238     0.456121   0.432689   0.0891993\n 0.263472   0.653417   0.635989  0.178665     0.15581    0.174212   0.659114\n 0.171028   0.4568     0.629753  0.359009     0.313404   0.296362   0.569698\n 0.0590787  0.526723   0.542721  0.264074     0.190703   0.202433   0.46146\n 0.496807   0.0602121  0.894362  0.756133  …  0.641323   0.535083   0.879839\n 0.456526   0.0791859  0.851944  0.713602     0.599456   0.493216   0.839557\n 0.163722   0.663498   0.538541  0.11823      0.0        0.113604   0.543552\n 0.158548   0.557259   0.465152  0.228057     0.113604   0.0        0.520192\n 0.402445   0.908204   0.854216  0.646264     0.543552   0.520192   0.0\n\n\nWe can see that \\(D\\) makes sense just by plotting \\(X_fps\\) colored by the sum of the distances to each points:\n\nexc = map(sum, eachcol(D))\n\ngl.scatter(X_fps, color = exc, markersize = 10)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>3d shape classification using persistent homology</span>"
    ]
  }
]