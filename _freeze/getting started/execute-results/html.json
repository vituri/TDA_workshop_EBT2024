{
  "hash": "04c6d472fca88e7b3079fea6c8a8ea60",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia \n\nexecute:\n  freeze: true  # re-render only when source changes\n  cache: true\n  warning: false\n---\n\n\n\n\n\n# Getting started\n\nNow you are convinced that Julia is really nice and fast, and that Topological data analysis is a very unique tool. It is time to start applying!\n\n## Persistent homology\n\nLet's quickly review what is persistent homology and why it is useful.\n\nGiven a finite metric space $M$, for each $\\epsilon > 0$ we create a simplicial complex $K_\\epsilon$ in such a way that $\\epsilon_1 < \\epsilon_2$ implies $K_{\\epsilon} \\subset K_{\\epsilon'}$.\n\n### Creating simplicial complexes\n\nThere are several ways to create this simplicial complex. One famous construction is the Vietoris-Rips complex:\n\n$$\nVR_\\epsilon(M) = \\{ [x_1, \\cdots, x_n] \\subset M \\; \\text{s.t.} \\; d(x_i, x_j) < \\epsilon, \\; \\forall i, j \\}\n$$\n\nthat is: if we put a ball $B_i$ of radius $2 \\epsilon$ around each point $x_i$, then \n\n$$\n[x_1, \\cdots, x_n] \\in VR_\\epsilon(M) \\Leftrightarrow \\cap B_i \\neq \\emptyset.\n$$\n\n![The Vietoris-Rips filtration of a metric space (on the left of each panel). As $\\epsilon$ increases, so do the amount of simplexes we have. Source: @vr.](images/getting-started/vr.png)\n\n### Creating sequences of vector spaces\n\nApplying the homology functor with field coefficients\n\n$$\nV_\\epsilon = H_n(K_\\epsilon)\n$$\n\non each of the simplicial complexes \n\n$$\n\\{ K_\\epsilon \\subseteq K_{\\epsilon'} \\; \\text{s.t.} \\; \\epsilon \\leq \\epsilon' \\}\n$$\n\nwe obtain a sequence of vector spaces together with linear transformations\n\n$$\n\\mathbb{V}(M) = \\{ V_\\epsilon \\to V_{\\epsilon'} \\; \\epsilon \\leq \\epsilon' \\}\n$$\n\ncalled a _persistent vector space_.\n\n### Simplifying \n\nSome very nice theorems^[citar aqui!!] prove that a persistent vector space can be decomposed as a sum of _interval modules_, which are the fundamental blocks of persistent vector spaces. Each one of these blocks represent the birth and death of a generator. Thus, $\\mathbb{V}(M)$ can summarised in two equivalent ways:\n\n- as a _barcode_: a (multi)set of real intervals $\\{ [a_i, b_i) \\subset \\mathbb{R}, \\; i \\in I \\}$.\n\n- as a _persistence diagram_: a subset of real plane above the diagonal of the form $\\{ (a_i, b_i) \\in \\mathbb{R}^2, \\; i \\in I \\}$.\n\nEach pair $(a_i, b_i)$ can be interpreted as follows: $a_i$ is the value of $\\epsilon$ at which a feature (i.e. a generator of $H_n(K_\\epsilon)$) was \"born\", and this generator persisted until it reached $b_i$. See the following image for the representation of a barcode.\n\nWe will use both these representations many times.\n\n![A Vietoris-Rips filtration and its respective barcode. Vertical lines represent \"slices\" at some values of $\\epsilon$. Source: @ghrist2008barcodes.](images/getting-started/ph.png)\n\n### Distances on persistence diagrams and stability\n\nThe _bottleneck distance_ can be defined on the set of persitence diagrams. Intuitively, it measures the \"effort\" to move the points of one diagram to the points of the other OR collapsing these points to the diagonal.\n\nIt is important to note that points very close to the diagonal (or, equivalently, intervals very short on a barcode) can be seen as \"noise\" or \"non relevant features\": they represent features that were born and lived for just a small time.\n\n![The bottleneck distance between two persistence diagrams (in blue and red). Source: [https://gudhi.inria.fr/doc/latest/group__bottleneck__distance.html](https://gudhi.inria.fr/doc/latest/group__bottleneck__distance.html)](images/getting-started/bottleneck.png)\n\n### Stability of the bottleneck distance\n\nThis distance is much more useful because of the _stability theorem_: metric spaces close to each other yield barcodes close to each other:\n\n$$\nd_b(\\mathbb{V}(M), \\mathbb{V}(N)) \\leq d_{GH}(M, N)\n$$\n\nwhere $M, N$ are finite metric spaces, $d_b$ is the bottleneck distance and $d_{GH}$ is the Gromov-Hausdorff distance on the set of metric spaces.\n\n::: {.callout-note title=\"Why is stability useful?\"}\n\nSuppose we have several metric spaces $X_1, \\ldots, X_n$ (let's say photos or 3d-objects) and we want to group these spaces by similarity (cats in one group, dogs in another). Calculating the Gromov-Hausdorff distance is a _very expensive calculation_!^[see [this excellent article by Matt Piekenbrock](https://peekxc.github.io/Mapper/articles/ShapeRecognition.html#gromov-hausdorff-distance) to get an idea of the complexity involved.]. Instead, we can use the bottleneck distance of each barcode $\\mathbb{V}(X_i)$ as a approximation to the geometry of $X_i$.\n\n:::\n\nThe following beautiful gifs can be found at the [Ripserer.jl](https://mtsch.github.io/Ripserer.jl/dev/generated/stability/) documentation, a Julia package that implements an efficient algorithm to calculate the barcode using the Vietoris-Rips filtration.\n\n![Taking random samples of the circle result in pretty similar persistent diagrams.](images/getting-started/rips1.gif)\n\n![Addin some noise to the circle does not modify so much the persistent diagram.](images/getting-started/rips2.gif)\n\n![The persistent diagram slowly deformates itself as we add more noise to the circle.](images/getting-started/rips3.gif)\n\n![Collapsing the circle also make the 1-dimensional persistence diagram get close to the diagonal.](images/getting-started/rips4.gif)\n\n## A better way to represent barcodes\n\nBarcodes are nice and \n! bottleneck is also a bit expensive\n! a representation in fixed form (vector, matrix, etc?)\n! important to use in machine learning algorithms!\n\n\n## Classic topology\n\nLet's start exploring some common objects in topology.\n\n\n\n\n\n::: {#2 .cell execution_count=0}\n``` {.julia .cell-code}\nusing MetricSpaces;\nimport CairoMakie as gl;\n\nimport Ripserer;\n# import PersistenceDiagrams as Pd\nimport Plots;\n\nfunction plot_barcode(bc)\nPlots.plot(\n    Plots.plot(bc)\n    ,Ripserer.barcode(bc)\n)\nend;\n```\n:::\n\n\n\n\n\n\n\n### Torus\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\nX = torus(1500)\ngl.scatter(X)\n```\n:::\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\nbc = Ripserer.ripserer(X, dim_max = 1, verbose = true, threshold = 4)\nplot_barcode(bc)\n```\n:::\n\n\n\n\n\n\n\n### Circle\n\n\n\n\n\n::: {#8 .cell execution_count=0}\n``` {.julia .cell-code}\nX = sphere(200, dim = 2)\ngl.scatter(X)\n```\n:::\n\n\n\n::: {#10 .cell execution_count=0}\n``` {.julia .cell-code}\nbv = Ripserer.ripserer(X, dim_max = 1, verbose = true)\nplot_barcode(bc)\n```\n:::\n\n\n\n\n\n\n\n### Sphere\n\n\n\n\n\n::: {#12 .cell execution_count=0}\n``` {.julia .cell-code}\nX = sphere(1500, dim = 3)\ngl.scatter(X)\n```\n:::\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\nbc = Ripserer.ripserer(X, dim_max = 1, verbose = true)\nplot_barcode(bc)\n```\n:::\n\n\n\n\n\n\n\n### A square with a hole\n\n\n\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code}\nX = rand(gl.Point2, 1500)\nfilter!(x -> (x[1]-0.5)^2 + (x[2]-0.5)^2 > 0.03, X)\ngl.scatter(X)\n```\n:::\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\nbc = Ripserer.ripserer(X, dim_max = 1, verbose = true)\nplot_barcode(bc)\n```\n:::\n\n\n\n\n\n\n\n### Two circles\n\n\n\n\n\n\n::: {#20 .cell execution_count=0}\n``` {.julia .cell-code}\nX = vcat(\n    sphere(150, dim = 2)\n    ,sphere(150, dim = 2) .|> x -> (x .+ (1, 1))\n)\n\ngl.scatter(X)\n```\n:::\n\n\n\n::: {#22 .cell execution_count=0}\n``` {.julia .cell-code}\nbc = Ripserer.ripserer(X, dim_max = 1, verbose = true)\nplot_barcode(bc)\n```\n:::\n\n\n",
    "supporting": [
      "getting started_files"
    ],
    "filters": [],
    "includes": {}
  }
}