{
  "hash": "6276453b04d30e7ada9c3971a9aa5f7f",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia \n\nexecute:\n  freeze: true  # re-render only when source changes\n  cache: true\n  warning: false\n---\n\n\n\n\n\n\n# Introduction\n\n## Why Julia for topological data analysis?\n\nIn a world ruled by Python (and, in some areas, R), why use an exquisite and new language like Julia in this workshop? You can find some good reasons in the book [Julia Data Science](https://juliadatascience.io/programmers), but I will give some in the context of topology:\n\n::: {.callout-tip title=\"Reason 1\"}\n\nJulia is fast. You won't need to use another language to make some expensive computation.\n\n:::\n\nLet's say you read about a new algorithm to calculate the Vietoris-Rips. If you are a R/Python user, *your algorithm won't be written in R/Python* simply because R/Python is slow. Fast code in R/Python is written in C, C++, Fortran or Rust; this is called the [two language problem](https://juliadatascience.io/julia_accomplish#sec:two_language). Julia solves this because with enought knowledge about the compiler and the language, you will get performance nearly as good as if it was written in C. Optimize Julia code is not a trivial task, but is way easier than learning another language just to get good performance in some functions.\n\n![The famous deep learning package [`torch`](https://github.com/pytorch/pytorch) in Python has its core written mostly in C++. Python is just a \"glue\" interface.](images/intro/torch.png)\n\n![The deep learning package [`Flux.jl`](https://github.com/FluxML/Flux.jl) is 100% written in Julia.](images/intro/flux.png)\n\n::: {.callout-tip title=\"Reason 2\"}\n\nIt is easy to use another language inside Julia.\n\n:::\n\nEven though Julia is fast and has a robust ecosystem, Python and R have many more packages already good-to-go. You can use them easily with tools like [PythonCall](https://github.com/JuliaPy/PythonCall.jl) or [RCall](https://github.com/JuliaInterop/RCall.jl).\n\n::: {.callout-tip title=\"Reason 3\"}\n\nJulia looks like mathematics and has an elegant syntax.\n\n:::\n\n1) Being able to mix LaTeX symbols with code can make the code way more readable.\n\nYou can find many nice examples on [BeautifulAlgorithms.jl](https://github.com/mossr/BeautifulAlgorithms.jl). Below are some common Julia code:\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\n# calculate the intersection of two vectors/sets\n[1, 2] ∩ [2, 3, 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1-element Vector{Int64}:\n 2\n```\n:::\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n# check if a value is in a vector/set\n1 ∉ [2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n# define a function in one line\nf(r) = π*r^2\n\nf(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n28.274333882308138\n```\n:::\n:::\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n# Euler's identity\nℯ^(im * π) + 1 |> round\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.0 + 0.0im\n```\n:::\n:::\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n# calculating the pairwise-distance between points in a set\nX = [1, 2, 3, 4]\nd(x, y) = abs(x - y)\n[d(xᵢ, xⱼ) for xᵢ ∈ X, xⱼ ∈ X]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4×4 Matrix{Int64}:\n 0  1  2  3\n 1  0  1  2\n 2  1  0  1\n 3  2  1  0\n```\n:::\n:::\n\n\n\n\n\n\n\n\n2) Easily apply a function to all elements of a vector/set:\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\nx = [1, 2, 3, 4]\n\n# broadcast\nsin.(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n```\n:::\n:::\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\n# mapping\nmap(sin, x)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n```\n:::\n:::\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\n# list comprehension\n[sin(x_i) for x_i ∈ x]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n```\n:::\n:::\n\n\n\n\n\n\n\n\n3) You can compose functions in the reading order \n\nInstead of writing\n\n\n\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nsin(cos(1))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.5143952585235492\n```\n:::\n:::\n\n\n\n\n\n\n\n\nyou can \"pipe\" the functions as in\n\n\n\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\n1 |> cos |> sin\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.5143952585235492\n```\n:::\n:::\n\n\n\n\n\n\n\n\n4) Julia is a functional programming language with type hierarchy, which means that we have \"categories\" (types) and \"functors\" (functions) mapping between the types; moreover, its polimorphism means that the functions depend on the type of its arguments.\n\nFor example, suppose you want to define the norm of a vector:\n\n\n\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\nx = [1, 2, 3]\n\n# define the norm of a Vector of Numbers\nnorm(x::Vector{<:Number}) = x.^2 |> sum |> sqrt\nnorm(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3.7416573867739413\n```\n:::\n:::\n\n\n\n\n\n\n\n\nYou can also define the norm of a function $f$ as the approximate integral of $|f|$ on the interval $[0, 1]$:\n\n\n\n\n\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\nstep_size = 0.0001\nnorm(f::Function) = [abs(f(x) * step_size) for x ∈ 0:step_size:1] |> sum\nnorm(sin)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.45973976729801924\n```\n:::\n:::\n\n\n\n\n\n\n\n\nwhich is very close to\n\n\n\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\nabs(cos(1) - cos(0))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.45969769413186023\n```\n:::\n:::\n\n\n\n\n\n\n\n\nWhy not define the norm of a text as the amount of characters?\n\n\n\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\nnorm(s::AbstractString) = length(s)\nnorm(\"Hello!\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n6\n```\n:::\n:::\n\n\n\n\n\n\n\n\n## Why TDA?\n\nTopological Data Analysis is a very curious field of mathematics that apply tools from topology and algebraic topology in the study of datasets. By \"datasets\", we almost always mean \"finite metric space\".\n\nThese tools can be divided in some broad categories:\n\n### Homological methods\n\nPersistence homology calculates the \"shape\" (homology groups) of a object on different scales, and compact this information into objects called \"barcodes\". This barcode can be vectorized and then inserted into machine learning models.\n\n### Graph reduction methods\n\nThe Mapper algorithm is the discrete version of the [Reeb graph](https://en.wikipedia.org/wiki/Reeb_graph). It captures the geometry of a dataset with respect to a given function (called \"filter\") and produce a graph of its pre-images clustered. There is also the Ball Mapper variant, which does not need a filter function and resembles the Vietoris-Rips filtration. These methods are useful to get a glimpse of the geometry (flares, holes) and areas of interest. For example: if your metric space is a dataset of measurements of patients with diabets, the Mapper graph can represent the patients and the shape of this graph can give insights about the type of diabetes one has.\n\n### Clustering methods\n\nAlgorithms like ToMATo are clustering algorithms: we have a metric space as input, and return a partition of this dataset. Clustering is useful whenever we need to \"group a set of objects in such a way that objects in the same group (called a cluster) are more similar to each other than to those in other groups (clusters)\"^[https://en.wikipedia.org/wiki/Cluster_analysis].\n\n## Why this minicourse?\n\nThis minicourse is a good opportunity for pure topologists to see how we can use TDA *in practice*. It will be even better for the applied mathematicians who can promptly recognize the tools and algorithms I am using.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}